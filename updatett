#!/usr/bin/env -S zsh -f
#
# updatett - Smart terminal tools updater with version tracking

set -uo pipefail

# Use TMPDIR if set, otherwise fallback to /tmp
: "${TMPDIR:=/tmp}"

# --- mkdir-based locking (to prevent concurrent runs) with stale-lock handling ---
LOCKDIR="${TMPDIR}/updatett.lock"
PIDFILE="${LOCKDIR}/pid"

ensure_lock() {
  if mkdir "$LOCKDIR" 2>/dev/null; then
    print -r -- "$$" >| "$PIDFILE" 2>/dev/null || true
    return 0
  fi

  # Lockdir exists; check for stale lock
  if [[ -d "$LOCKDIR" ]]; then
    local oldpid=""
    [[ -f "$PIDFILE" ]] && oldpid=$(<"$PIDFILE")
    if [[ -n "$oldpid" ]] && ! kill -0 "$oldpid" 2>/dev/null; then
      # Stale lock: best-effort cleanup
      rm -f "$PIDFILE" 2>/dev/null || true
      rmdir "$LOCKDIR" 2>/dev/null || true
      # Try once more
      if mkdir "$LOCKDIR" 2>/dev/null; then
        print -r -- "$$" >| "$PIDFILE" 2>/dev/null || true
        return 0
      fi
    fi
  fi

  print -r -- "Another updatett instance appears to be running. Exiting."
  exit 1
}

ensure_lock

# TTY detection
IS_TTY=1
[[ -t 1 ]] || IS_TTY=0

# Colors & symbols (TTY-aware; raw escapes for printf, NOT prompt %{})
if [[ "$IS_TTY" -eq 1 && -z "${NO_COLOR:-}" ]]; then
  BLUE=$'\033[0;34m'
  GREEN=$'\033[0;32m'
  YELLOW=$'\033[1;33m'
  RED=$'\033[0;31m'
  GRAY=$'\033[90m'
  DIM=$'\033[2m'
  BOLD=$'\033[1m'
  NC=$'\033[0m'
else
  BLUE=""; GREEN=""; YELLOW=""; RED=""; GRAY=""; DIM=""; BOLD=""; NC=""
fi

# Symbols
CHECK="✓"
CROSS="✗"
SKIP="○"
ARROW="→"

# Spinner frames
SPINNER_FRAMES=("⠋" "⠙" "⠹" "⠸" "⠼" "⠴" "⠦" "⠧" "⠇" "⠏")

# Create secure temp directory
TEMP_DIR=$(mktemp -d "${TMPDIR}/updatett.XXXXXXXXXX") || {
    print -r -- "${RED}Failed to create temporary directory${NC}" >&2
    # Ensure lock is removed if mktemp fails
    rm -f "$PIDFILE" 2>/dev/null || true
    rmdir "$LOCKDIR" 2>/dev/null || true
    exit 1
}

# Track updater child PIDs so we can terminate on signals
typeset -ag UPDATER_PIDS=()

# Cleanup function
cleanup() {
    # If signaled, prefer signal-coded exit statuses
    local code="${EXIT_CODE_OVERRIDE:-$?}"

    # Kill spinner if running
    if [[ -n "${spinner_pid:-}" ]] && kill -0 "$spinner_pid" 2>/dev/null; then
        kill "$spinner_pid" 2>/dev/null || true
        wait "$spinner_pid" 2>/dev/null || true
    fi

    # Terminate any in-flight updater children
    if (( ${#UPDATER_PIDS[@]} )); then
        for pid in "${UPDATER_PIDS[@]}"; do
            if kill -0 "$pid" 2>/dev/null; then
                kill "$pid" 2>/dev/null || true
            fi
        done
        # Give them a brief moment, then force kill if needed
        sleep 0.2
        for pid in "${UPDATER_PIDS[@]}"; do
            if kill -0 "$pid" 2>/dev/null; then
                kill -9 "$pid" 2>/dev/null || true
            fi
        done
    fi

    # Remove temp directory
    if [[ -d "$TEMP_DIR" ]]; then
        rm -rf "$TEMP_DIR"
    fi

    # Remove lock directory
    rm -f "$PIDFILE" 2>/dev/null || true
    rmdir "$LOCKDIR" 2>/dev/null || true

    # If we're exiting with an error, show message
    if [[ "$code" -ne 0 ]]; then
        print -ru2 -- ""
        print -ru2 -- "${RED}Script terminated with error (exit code: $code)${NC}"
    fi

    exit "$code"
}

# Set up traps with explicit signal mapping
trap 'EXIT_CODE_OVERRIDE=$((128+2)); cleanup' INT
trap 'EXIT_CODE_OVERRIDE=$((128+15)); cleanup' TERM
trap 'cleanup' EXIT

# ═══════════════════════════════════════════════════════════════
# TOOLS CONFIGURATION
# Format: "Display Name|check_command|version_command|update_command"
# ═══════════════════════════════════════════════════════════════

TOOLS=(
    "uv|uv|uv --version|uv self update"
    "Claude CLI|claude|claude --version|claude update"
    "Gemini CLI|gemini|gemini --version|npm install -g @google/gemini-cli@latest"
    "OpenAI Codex|SKIP_CHECK|npm list -g @openai/codex|npm install -g @openai/codex@latest"
    "Wrangler|wrangler|wrangler --version|npm install -g wrangler@latest"
    "Stripe Node.js|SKIP_CHECK|npm list -g stripe|npm install -g stripe@latest"
)

# ═══════════════════════════════════════════════════════════════

# Global spinner PID
spinner_pid=""

# Spinner function
spin() {
    local pid=$1
    local delay=0.1
    local frame=1
    local num_frames=${#SPINNER_FRAMES[@]}

    # Only show spinner if TTY
    if [[ "$IS_TTY" -ne 1 ]]; then
        while kill -0 "$pid" 2>/dev/null; do
            sleep $delay
        done
        return
    fi

    while kill -0 "$pid" 2>/dev/null; do
        printf "\r${DIM}[%d/%d]${NC} %-20s ${DIM}%s${NC} ${YELLOW}%s${NC} " \
            "$current_index" "$total" "$current_name" "$current_version" "${SPINNER_FRAMES[$frame]}"
        frame=$(( (frame % num_frames) + 1 ))
        sleep $delay
    done
}

# Clean version extraction
get_version() {
    local cmd=$1

    # Special handling for npm list commands
    if [[ $cmd == *"npm list -g @openai/codex"* ]]; then
        local version
        version=$(npm list -g @openai/codex 2>/dev/null | grep '@openai/codex@' | grep -Eo '[0-9]+(\.[0-9]+){1,3}(-[A-Za-z0-9._-]+)?' | head -n1)
        print -r -- "$version"
        return
    elif [[ $cmd == *"npm list -g stripe"* ]]; then
        local version
        version=$(npm list -g stripe 2>/dev/null | grep ' stripe@' | grep -Eo '[0-9]+(\.[0-9]+){1,3}(-[A-Za-z0-9._-]+)?' | head -n1)
        print -r -- "$version"
        return
    fi

    # Regular extraction for other commands
    local output
    local -a argv; argv=("${(z)cmd}")
    if command -v "${argv[1]}" >/dev/null 2>&1; then
        output="$("${argv[@]}" 2>/dev/null | head -n1)" || output=""
    else
        output=""
    fi

    local version
    version=$(print -r -- "$output" | grep -Eo '[0-9]+(\.[0-9]+){1,3}(-[A-Za-z0-9._-]+)?' | head -n1)
    if [[ -n "$version" ]]; then
        print -r -- "$version"
    elif [[ -n "$output" ]] && [[ ${#output} -lt 64 ]]; then
        print -r -- "$output"
    fi
}

# Update a single tool
update_tool() {
    local tool_spec=$1
    local index=$2

    IFS='|' read -r name check_cmd version_cmd update_cmd <<< "$tool_spec"
    current_index=$index
    current_name="$name"

    # Create unique temp files for this tool
    local log_file="${TEMP_DIR}/tool_${index}.log"
    local status_file="${TEMP_DIR}/tool_${index}.status"

    # Initial status line
    printf "${DIM}[%d/%d]${NC} %-20s " "$current_index" "$total" "$name"

    # Check if command exists (unless it's an npm package without CLI)
    if [[ "$check_cmd" != "SKIP_CHECK" ]]; then
        if ! command -v "$check_cmd" &> /dev/null; then
            printf "${GRAY}${SKIP} not installed${NC} ${DIM}(${check_cmd} not found)${NC}\n"
            return 0
        fi
    fi

    # Get current version
    current_version=$(get_version "$version_cmd")
    if [[ -n "$current_version" ]]; then
        printf "${DIM}%s${NC} " "$current_version"
    fi

    # Run update with spinner (per-tool error handling) using safe parsing
    {
        local -a argv; argv=("${(z)update_cmd}")
        "${argv[@]}" &> "$log_file"
        print -r -- "$?" >| "$status_file"
    } &
    local update_pid=$!
    UPDATER_PIDS+=("$update_pid")

    # Start spinner in background (TTY-aware)
    spin $update_pid &
    spinner_pid=$!

    # Wait for update to complete
    wait $update_pid 2>/dev/null || true

    # Stop spinner
    if [[ -n "$spinner_pid" ]] && kill -0 "$spinner_pid" 2>/dev/null; then
        kill "$spinner_pid" 2>/dev/null || true
        wait "$spinner_pid" 2>/dev/null || true
    fi
    spinner_pid=""

    # Remove finished pid from tracking
    for i in {1..${#UPDATER_PIDS[@]}}; do
        if [[ "${UPDATER_PIDS[i]}" == "$update_pid" ]]; then
            unset "UPDATER_PIDS[i]"
            break
        fi
    done

    # Check result
    local exit_code
    if [[ -f "$status_file" ]]; then
        exit_code=$(<"$status_file")
    else
        exit_code=1
    fi

    # Clear spinner line (TTY-aware)
    if [[ "$IS_TTY" -eq 1 ]]; then
        printf "\r"
    fi
    printf "${DIM}[%d/%d]${NC} %-20s " "$current_index" "$total" "$name"

    if [[ "$exit_code" == "0" ]]; then
        # Get new version after update
        local new_version=$(get_version "$version_cmd")

        if [[ -n "$current_version" && -n "$new_version" ]]; then
            if [[ "$current_version" == "$new_version" ]]; then
                printf "${DIM}%s${NC} ${GREEN}${CHECK}${NC} ${DIM}(already latest)${NC}\n" "$current_version"
            else
                printf "${DIM}%s${NC} ${ARROW} ${GREEN}%s${NC} ${GREEN}${CHECK}${NC}\n" "$current_version" "$new_version"
            fi
        elif [[ -n "$new_version" ]]; then
            printf "${ARROW} ${GREEN}%s${NC} ${GREEN}${CHECK}${NC}\n" "$new_version"
        else
            printf "${ARROW} ${GREEN}${CHECK}${NC} ${DIM}(updated)${NC}\n"
        fi
    else
        printf "${DIM}%s${NC} ${ARROW} ${RED}${CROSS}${NC}" "$current_version"

        if [[ -f "$log_file" ]]; then
            local error
            error=$(grep -Eim1 'error|failed|permission' "$log_file" 2>/dev/null)
            if [[ -n "$error" ]]; then
                error="${error:0:80}"
                printf " ${DIM}${RED}(%s...)${NC}" "$error"
            else
                printf " ${DIM}${RED}(update failed)${NC}"
            fi
        else
            printf " ${DIM}${RED}(update failed)${NC}"
        fi
        printf "\n"
    fi
}

# Main
main() {
    if [[ "$IS_TTY" -eq 1 ]]; then
        command -v clear >/dev/null 2>&1 && clear
    fi

    print -r -- ""
    print -r -- "${BOLD}${BLUE}updatett${NC} ${DIM}• Terminal Tools Updater${NC}"
    print -r -- "${DIM}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    print -r -- ""

    total=${#TOOLS[@]}
    local index=1

    # Process all tools
    for tool in "${TOOLS[@]}"; do
        update_tool "$tool" "$index"
        ((index++))
    done

    print -r -- ""
    print -r -- "${DIM}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    print -r -- ""
}

# Run main function
main
